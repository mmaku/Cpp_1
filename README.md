Cpp_1
=====

First term of C++ course at Math Institute,  University of Wrocław

COURSE SYLLABUS  (in Polish)
===============

1. Algorytmiczne rozwiązywanie problemów na przykładzie algorytmu Euklidesa. Stan i przepływ sterowania. Formalizacja algorytmu, zapis w języku formalnym i wizualizacja za pomocą schematu blokowego.

2. Elementy architektury komputerów, kod maszynowy, języki wysokiego poziomu a kod maszynowy, struktura prostych programów w c++ na podstawie przykładu z algorytmem Euklidesa - funkcje, funkcja main. Korzystanie z biblioteki iostream dla wyjścia. Podstawowe typy danych - typ całkowitoliczbowy. Pętle do while oraz while. Oddzielanie obliczeń i wejścia-wyjścia. Łatwość zrozumienia przez czytelnika jako kryterium oceny jakości kodu.

3. Binarny typ zmiennopozycyjny, problemy z dokładną reprezentacją liczb o skończonych rozwinięciach dziesiętnych i pułapki konwersji automatycznych. Typ logiczny bool. Sposoby reprezentowania w komputerze liter - strony kodowe oraz standard UNICODE. Typ znakowy i typy napisowe. Instrukcja warunkowa.

4. Instrukcja switch. Wyrażenia warunkowe. Przegląd operatorów arytmetycznych, logicznych, bitowych, efekty uboczne. Brak ustalonej kolejności obliczania argumentów i konsekwencje dla wyrażeń z efektami ubocznymi. Komentarze. Pętla for. Konsolowy strumień wejściowy. Stany strumienia i ich sprawdzanie. Wejście odporne na błędy. Strumienie napisowe. Manipulatory strumieni.

5. Błędy w programowaniu: składniowe, logiczne i otoczenia. Asercje. Funkcje testujące (unit-test) jako integralna część rozwiązania. Metodologia test-driven-development. Funkcje matematyczne w bibliotece standardowej. Strumienie plikowe.

6. Typy danych tworzone przez programistę - struktury jako programistyczny odpowiednik iloczynu kartezjańskiego. Sygnatury funkcji i przeciążanie operatora wyjścia dla typu użytkownika. Referencje jako narzędzie do konstruowania własnych funkcji z efektem ubocznym. Przeciążanie innych funkcji, argumenty domyślne. Od struktur do klas – wyposażanie struktur w metody specjalne, np. konstruktory, oraz zwykłe metody.

7. Klasy. Niezmiennik. Hermetyzacja jako sposób kontroli niezmiennika. Stosowanie właściwych abstrakcji jako sposób na zamianę trudnych błędów logicznych na proste błędy składniowe, oraz na podział pracy w zespołach. Operator wejścia dla klas. Kontrola stanu strumienia wejściowego w zależności od sensowności wejścia. Wstęp do wskaźników i adresowania pośredniego. Wskaźnik this. Operatory jako metody i jako funkcje.

8. Biblioteka standardowa. Kolekcje na przykładzie wzorca std::vector. Konstrukcja, Dostęp stosowy, indeksowany, metody. Klasa napisowa std::string jako kolekcja liter i nie tylko. Tablice jako wbudowany typ kolekcji elementów, wskaźniki jako interfejs dostępu do tablicy. Kategorie operacji na wskaźnikach (pobranie, porównanie, dereferencja, inkrementacja, dekrementacja, dostęp indeksowany). Tablice jako obiekt nietypowy - brak przekazania przez wartość. Uogólnienie interfejsu wskaźnikowego na iteratory do kolekcji standardowych. Inwalidacja iteratorów, Wskaźniki do funkcji. Funktory. Wyrażenia lambda.

9. Wstęp do dziedziczenia i wzorców. Wskaźniki i referencje do klasy bazowej. Funkcje wirtualne. Wzorce funkcji.
